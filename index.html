<head>
    <style>
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
        }

        td>input {
            width: 50px;
        }

        #center>* {
            margin: auto;
            text-align: center
        }

        body {
            font-family: sans-serif;
            width: 100%;
            height: 100%;
            margin: 0;
        }

        #center {
            position: relative;
            top: 50%;
            -webkit-transform: translateY(-50%);
            -ms-transform: translateY(-50%);
            transform: translateY(-50%);
        }
    </style>
</head>
<div id="center">
    <h1>Knucklebones Solver</h1>
    <div>Opponent board</div>
    <table id="grid1">
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
    </table>
    <br>
    <div>Your board</div>
    <table id="grid0">
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
    </table>
    <br>
    <div><input id="roll" type="number" placeholder="Your roll"></div>
    <div><input id="depth" type="number" placeholder="Search depth [5]"></div>
    <br>
    <div><button onclick="btn_solve_clicked()">Solve</button></div>
    <br>
    <div>Place dice: <span id="column"></span></div>
    <br>
    <div>Expected advantage in <span id="out_depth">?</span> moves: <span id="score"></span></div>
</div>
<script>
const COLUMN_REPR = ["Left", "Center", "Right"];
const GRID_OFFSET = 18;
const COLUMN_OFFSET = 6;

// micro optimization, 2x faster than reduce if a slice would've been required
function sum(arr, start, end) {
    let total = 0;
    for (; start < end; ++start)
        total += arr[start];
    return total
}

// Micro optimization, 4x faster than arr.sort() for n=6
function insertion_sort(arr) {
    for(let i=1; i<6; ++i) {
		const value = arr[i];
		for (var j=i-1; 0 <= j && arr[j] <= value; j--) 
			arr[j+1] = arr[j];
		arr[j+1] = value;
	}
}

class Board {
    constructor(grids) {
        this.grids = grids;
    }

    place(number, grid_index, column_index) {
        ++this.grids[GRID_OFFSET * grid_index + COLUMN_OFFSET * column_index + number - 1]; // +1 to selected grid
        this.grids[GRID_OFFSET * (1 - grid_index) + COLUMN_OFFSET * column_index + number - 1] = 0; // reset other grid counter
    }

    // Micro optimization, 2x faster than map + sum + eval_column
    eval() {
        let total = 0;
        for (let i = 0; i < 3; ++i) {
            for (let j = 0; j < 6; ++j) {
                const offset = COLUMN_OFFSET * i + j;
                total += (j + 1) * this.grids[offset] * this.grids[offset];
                total -= (j + 1) * this.grids[GRID_OFFSET + offset] * this.grids[GRID_OFFSET + offset];
            }
        }
        return total
    }

    is_game_over() {
        return sum(this.grids, 0, GRID_OFFSET) == 9
            || sum(this.grids, GRID_OFFSET, GRID_OFFSET + GRID_OFFSET) == 9;
    }

    is_column_full(grid_index, column_index) {
        const offset = GRID_OFFSET * grid_index + COLUMN_OFFSET * column_index;
        return sum(this.grids, offset, offset+6) == 3;
    }
}

function minimax(board, depth, maximizing_player) {
    if (depth == 0 || board.is_game_over()) return board.eval();

    const roll_scores = [];
    if (maximizing_player) {
        for (let roll = 1; roll < 7; ++roll) {
            let highest_column_score = Number.NEGATIVE_INFINITY;
            for (let column_index = 0; column_index < 3; ++column_index) {
                if (board.is_column_full(0, column_index)) continue;
                const new_board = new Board(board.grids.slice());
                new_board.place(roll, 0, column_index);
                highest_column_score = Math.max(highest_column_score, minimax(new_board, depth - 1, false));
            }
            roll_scores.push(highest_column_score);
        }
    } else {
        for (let roll = 1; roll < 7; ++roll) {
            let lowest_column_score = Number.POSITIVE_INFINITY;
            for (let column_index = 0; column_index < 3; ++column_index) {
                if (board.is_column_full(1, column_index)) continue;
                const new_board = new Board(board.grids.slice());
                new_board.place(roll, 1, column_index);
                lowest_column_score = Math.min(lowest_column_score, minimax(new_board, depth - 1, true));
            }
            roll_scores.push(lowest_column_score);
        }
    }
    // median score for each roll given best dice position
    // never use mean for heavy tailed distributions
    // this is heavy tailed because of score multiplication
    insertion_sort(roll_scores);
    return (roll_scores[2] + roll_scores[3]) / 2;
}

function solve(board, depth, roll) {
    let highest_column = null;
    let highest_column_score = Number.NEGATIVE_INFINITY;
    for (let column_index = 0; column_index < 3; ++column_index) {
        if (board.is_column_full(0, column_index)) continue; // skip full column
        const new_board = new Board(board.grids.slice());
        new_board.place(roll, 0, column_index);
        const column_score = minimax(new_board, depth, false);
        if (column_score > highest_column_score) {
            highest_column_score = column_score;
            highest_column = column_index;
        }
    }
    return [highest_column, highest_column_score];
}

function btn_solve_clicked() {
    const roll_string = document.getElementById("roll").value.trim();
    if (roll_string.length === 0) return console.error("Invalid roll");
    const roll = parseInt(roll_string)

    const depth_string = document.getElementById("depth").value.trim();
    let depth;
    if (depth_string.length === 0) depth = 5;
    else depth = parseInt(depth_string)

    // 36 = 2 grids * 3 columns * 6 counters
    const board = new Board(new Array(36).fill(0));
    for (let grid_index = 0; grid_index < 2; ++grid_index) {
        const rows = document.getElementById("grid" + grid_index).lastChild.children;
        for (const row of rows) {
            const cells = row.getElementsByTagName("input");
            for (let column_index = 0; column_index < 3; ++column_index) {
                const value = cells[column_index].value.trim()
                if (value.length === 0) continue;
                board.place(parseInt(value), grid_index, column_index)
            }
        }
    }

    const start = Date.now();
    const [highest_column, highest_column_score] = solve(board, depth, roll);
    console.log("Elapsed:", Math.round((Date.now() - start)));

    document.getElementById("column").innerText = COLUMN_REPR[highest_column];
    document.getElementById("out_depth").innerText = depth;
    document.getElementById("score").innerText = Math.round(highest_column_score * 100) / 100;
}

function test() {
    const grids = [
        0,0,0,0,0,2, 0,0,0,0,0,0, 0,0,0,0,0,0,
        0,0,0,0,0,0, 1,0,1,0,1,0, 0,1,0,1,0,0];
    const board = new Board(grids);
    const start = Date.now();
    const roll_results = [ -12, -17, -20, -23, -16, -29 ];
    for (let i=10000000; i--;) {
        //board.is_column_full(1, 1);
        //const a = grids !== undefined ? grids : new Array(36).fill(0);
        //insertion_sort([ -12, -17, -20, -23, -16, -29 ]);
        //board.is_game_over()
        board.eval()
    }
    console.log("Test elapsed:", Math.round((Date.now() - start)));
}

</script>
