<head>
    <style>
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type=number] {
            -moz-appearance: textfield;
        }

        td>input {
            width: 50px;
        }

        #center>* {
            margin: auto;
            text-align: center
        }

        body {
            font-family: sans-serif;
            width: 100%;
            height: 100%;
            margin: 0;
        }

        #center {
            position: relative;
            top: 50%;
            -webkit-transform: translateY(-50%);
            -ms-transform: translateY(-50%);
            transform: translateY(-50%);
        }
    </style>
</head>
<div id="center">
    <h1>Knucklebones Solver</h1>
    <div>Opponent board</div>
    <table id="grid1">
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
    </table>
    <br>
    <div>Your board</div>
    <table id="grid0">
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
        <tr>
            <td><input type="number"></td>
            <td><input type="number"></td>
            <td><input type="number"></td>
        </tr>
    </table>
    <br>
    <div><input id="roll" type="number" placeholder="Your roll"></div>
    <div><input id="depth" type="number" placeholder="Search depth [5]"></div>
    <br>
    <div><button onclick="btn_solve_clicked()">Solve</button></div>
    <br>
    <div>Place dice: <span id="column"></span></div>
    <br>
    <div>Expected advantage in <span id="out_depth">?</span> moves: <span id="score"></span></div>
</div>
<script>
const COLUMN_REPR = ["Left", "Center", "Right"];

function sum(arr) {
    return arr.reduce((a, b) => a + b, 0);
}

// Micro optimization, 100x faster than structured clone, 2x faster than loop + slice
function clone_grids(grids) {
    const grid0 = grids[0], grid1 = grids[1];
    return [[grid0[0].slice(), grid0[1].slice(), grid0[2].slice()],
        [grid1[0].slice(), grid1[1].slice(), grid1[2].slice()]];
}

// Micro optimization, 4x faster than arr.sort() for n=6
function insertion_sort(arr) {
    for(let i=1; i<6; ++i) {
		const value = arr[i];
		for (var j=i-1; 0 <= j && arr[j] <= value; j--) 
			arr[j+1] = arr[j];
		arr[j+1] = value;
	}
}

class Board {
    constructor(grids) {
        // Columns are an Array(6) where each value is the 
        //   number of instances of that number in that column
        if (grids !== undefined) {
            this.grids = grids;
        } else {
            this.grids = [[],[]];
            for (let i = 0; i < 2; ++i)
                for (let j = 0; j < 3; ++j)
                    this.grids[i].push(new Array(6).fill(0))
        }
    }

    place(number, grid_index, column_index) {
        ++this.grids[grid_index][column_index][number - 1]; // +1 to selected grid
        this.grids[1 - grid_index][column_index][number - 1] = 0; // reset other grid counter
    }

    // Micro optimization, 2x faster than map + sum + eval_column
    eval() {
        let total = 0;
        const grid0 = this.grids[0], grid1 = this.grids[1];
        for (let i = 0; i < 3; ++i) {
            for (let j = 0; j < 6; ++j) {
                total += (j + 1) * grid0[i][j] * grid0[i][j];
                total -= (j + 1) * grid1[i][j] * grid1[i][j];
            }
        }
        return total
    }

    is_game_over() {
        for (let i = 0; i < 2; ++i)
            if (sum(this.grids[i].map(sum)) == 9) return true;
        return false
    }

    is_column_full(grid_index, column_index) {
        return sum(this.grids[grid_index][column_index]) == 3;
    }
}

function minimax(board, depth, maximizing_player) {
    if (depth == 0 || board.is_game_over()) return board.eval();

    const roll_scores = [];
    if (maximizing_player) {
        for (let roll = 1; roll < 7; ++roll) {
            let highest_column_score = Number.NEGATIVE_INFINITY;
            for (let column_index = 0; column_index < 3; ++column_index) {
                if (board.is_column_full(0, column_index)) continue;
                const new_board = new Board(clone_grids(board.grids));
                new_board.place(roll, 0, column_index);
                highest_column_score = Math.max(highest_column_score, minimax(new_board, depth - 1, false));
            }
            roll_scores.push(highest_column_score);
        }
    } else {
        for (let roll = 1; roll < 7; ++roll) {
            let lowest_column_score = Number.POSITIVE_INFINITY;
            for (let column_index = 0; column_index < 3; ++column_index) {
                if (board.is_column_full(1, column_index)) continue;
                const new_board = new Board(clone_grids(board.grids));
                new_board.place(roll, 1, column_index);
                lowest_column_score = Math.min(lowest_column_score, minimax(new_board, depth - 1, true));
            }
            roll_scores.push(lowest_column_score);
        }
    }
    // median score for each roll given best dice position
    // never use mean for heavy tailed distributions
    // this is heavy tailed because of score multiplication
    insertion_sort(roll_scores);
    return (roll_scores[2] + roll_scores[3]) / 2;
}

function solve(board, depth, roll) {
    let highest_column = null;
    let highest_column_score = Number.NEGATIVE_INFINITY;
    for (let column_index = 0; column_index < 3; ++column_index) {
        if (board.is_column_full(0, column_index)) continue; // skip full column
        const new_board = new Board(clone_grids(board.grids));
        new_board.place(roll, 0, column_index);
        const column_score = minimax(new_board, depth, false);
        if (column_score > highest_column_score) {
            highest_column_score = column_score;
            highest_column = column_index;
        }
    }
    return [highest_column, highest_column_score];
}

function btn_solve_clicked() {
    const roll_string = document.getElementById("roll").value.trim();
    if (roll_string.length === 0) return console.error("Invalid roll");
    const roll = parseInt(roll_string)

    const depth_string = document.getElementById("depth").value.trim();
    let depth;
    if (depth_string.length === 0) depth = 5;
    else depth = parseInt(depth_string)

    const board = new Board();
    for (let grid_index = 0; grid_index < 2; ++grid_index) {
        const rows = document.getElementById("grid" + grid_index).lastChild.children;
        for (const row of rows) {
            const cells = Array.from(row.getElementsByTagName("input"));
            for (const [column_index, cell] of cells.entries()) {
                const value = cell.value.trim();
                if (value.length === 0) continue;
                board.place(parseInt(value), grid_index, column_index)
            }
        }
    }

    const start = Date.now();
    const [highest_column, highest_column_score] = solve(board, depth, roll);
    console.log("Elapsed:", Math.round((Date.now() - start)));

    document.getElementById("column").innerText = COLUMN_REPR[highest_column];
    document.getElementById("out_depth").innerText = depth;
    document.getElementById("score").innerText = Math.round(highest_column_score * 100) / 100;
}

function test() {
    const grids = [[[0,0,0,0,0,2],[0,0,0,0,0,0],[0,0,0,0,0,0]],[[0,0,0,0,0,0],[1,0,1,0,1,0],[0,1,0,1,0,0]]];
    const board = new Board(grids);
    const start = Date.now();
    const roll_results = [ -12, -17, -20, -23, -16, -29 ];
    for (let i=10000000; i--;) {
        insertion_sort([ -12, -17, -20, -23, -16, -29 ]);
    }
    console.log("Test elapsed:", Math.round((Date.now() - start)));
}

</script>
